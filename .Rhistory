data.frame(Dist = c("Benini", "Beta", "Beta-Normal", "Birnbaum-Saunders",
"Chisq", "Dagum", "Exponential", "Exp-Geometric",
"Exp-Logarithmic", "Exp-Poisson", "F", "Fisk",
"Frechet", "Gamma", "Gaussian", "Gompertz", "Gumbel",
"Kumaraswamy", "Laplace", "Lindley", "Logistic",
"Loggamma", "Lognormal", "Lomax",
"Makeham", "Maxwell", "Nakagami", "Paralogistic",
"Pareto", "Perks", "Rayleigh", "Rice",
"Singh-Maddala", "Skewnormal", "t", "Topp-Leone",
"Triangular", "Uniform", "Weibull", "Poisson",
"Negative_Binomial"),
pdf = c("dbenini", "dbeta", "dbetanorm", "dbisa", "dchisq",
"ddagum", "dexp", "dexpgeom", "dexplog", "dexppois",
"df", "dfisk", "dfrechet", "dgamma", "dnorm",
"dgompertz", "dgumbel", "dkumar", "dlaplace",
"dlind", "dlogis", "dlgamma", "dlnorm",
"dlomax", "dmakeham", "dmaxwell", "dnaka",
"dparalogistic", "dpareto", "dperks", "dgenray",
"drice", "dsinmad", "dskewnorm", "dt", "dtopple",
"dtriangle", "dunif", "dweibull", "dpois", "dnbinom"),
fx = c("rbenini", "rbeta", "rbetanorm", "rbisa", "rchisq",
"rdagum", "rexp", "rexpgeom", "rexplog", "rexppois",
"rf", "rfisk", "rfrechet", "rgamma", "rnorm",
"rgompertz", "rgumbel", "rkumar", "rlaplace",
"rlind", "rlogis", "rlgamma", "rlnorm",
"rlomax", "rmakeham", "rmaxwell", "rnaka",
"rparalogistic", "rpareto", "rperks", "rgenray",
"rrice", "rsinmad", "rskewnorm", "rt", "rtopple",
"rtriangle", "runif", "rweibull", "rpois", "rnbinom"),
Lower = as.numeric(c(params[1], 0, -Inf, rep(0, 9),
params[1], 0, -Inf, 0, -Inf, 0, -Inf,
0, -Inf, -Inf, rep(0, 6),
params[1], rep(0, 4), -Inf, -Inf, 0,
params[1], params[1], 0, 0, 0)),
Upper = as.numeric(c(Inf, 1, rep(Inf, 15), 1, rep(Inf, 17),
1, params[2], params[2], Inf, Inf, Inf)))
calc_theory(fx = function(x) pis[1] * dnorm(x, mus[1], sigmas[1]) +
pis[2] * dnorm(x, mus[2], sigmas[2]),
lower = -Inf, upper = Inf)
library(SimMultiCorrData)
library(devtools)
?`SimMultiCorrData-package`
devtools::build_vignettes()
library(SimMultiCorrData)
C <- find_constants("Polynomial", -0.2885049, -1.1540195, 1.7930221, 6.1732675)
C <- find_constants("Polynomial", -0.2885049, -1.1540195, 1.7930221, 6.1732675, n = 50)
C <- find_constants("Polynomial", -0.2885049, -1.1540195, 1.7930221, 6.1732675, Six = seq(-50, 50, 0.01), n = 50)
library(distr)
?UnivarMixingDistribution
UnivarMixingDistribution
?sample
options(scipen = 999)
library("SimMultiCorrData")
library("gridExtra")
###########################################################################
### Section 5: Correlation matrix validation example
###########################################################################
Dist <- c("Logistic", "Weibull")
Params <- list(c(0, 1), c(3, 5))
Stcum1 <- calc_theory(Dist[1], Params[[1]])
Stcum2 <- calc_theory(Dist[2], Params[[2]])
Stcum <- rbind(Stcum1, Stcum2)
rownames(Stcum) <- Dist
colnames(Stcum) <- c("mean", "sd", "skew", "skurtosis", "fifth", "sixth")
Stcum
Six <- list(seq(1.7, 1.8, 0.01), seq(0.10, 0.25, 0.01))
marginal <- list(0.3)
lam <- 0.5
pois_eps <- 0.0001
size <- 2
prob <- 0.75
nb_eps <- 0.0001
Rey <- matrix(0.4, 5, 5)
diag(Rey) <- 1
valid1 <- valid_corr(k_cat = 1, k_cont = 2, k_pois = 1, k_nb = 1,
method = "Polynomial", means = Stcum[, 1], vars = Stcum[, 2]^2,
skews = Stcum[, 3], skurts = Stcum[, 4], fifths = Stcum[, 5],
sixths = Stcum[, 6], Six = Six, marginal = marginal, lam = lam,
size = size, prob = prob, rho = Rey)
# not shown in paper: check Rey using 2nd method to also get a valid result
valid2 <- valid_corr2(k_cat = 1, k_cont = 2, k_pois = 1, k_nb = 1,
method = "Polynomial", means = Stcum[, 1], vars = Stcum[, 2]^2,
skews = Stcum[, 3], skurts = Stcum[, 4], fifths = Stcum[, 5],
sixths = Stcum[, 6], Six = Six, marginal = marginal, lam = lam,
pois_eps = pois_eps, size = size, prob = prob, nb_eps = nb_eps,
rho = Rey)
F_lower <- calc_lower_skurt(method = "Fleishman", skews = 0,
Skurt = seq(1.1, 2, 0.01))
F_lower$Min
F_lower$Invalid.C
F_lower$SkurtCorr1
H_lower <- calc_lower_skurt(method = "Polynomial", skews = Stcum[2, 3],
fifths = Stcum[2, 5], sixths = Stcum[2, 6] + valid1$sixth_correction[2],
Skurt = seq(0.07, 1, 0.001))
H_lower$Min
H_lower$Invalid.C[which.min(H_lower$Invalid.C$skurtosis), ]
H_lower$SkurtCorr1
H_lower$Time
pis <- c(0.3, 0.4, 0.2, 0.1)
cumsum(pis)
?rcorrvar
options(scipen = 999)
seed <- 1234
n <- 10000
Dist <- c("Logistic", "Weibull")
Params <- list(c(0, 1), c(3, 5))
Stcum1 <- calc_theory(Dist[1], Params[[1]])
Stcum2 <- calc_theory(Dist[2], Params[[2]])
Stcum <- rbind(Stcum1, Stcum2)
rownames(Stcum) <- Dist
colnames(Stcum) <- c("mean", "sd", "skew", "skurtosis", "fifth", "sixth")
Stcum
Six <- list(seq(1.7, 1.8, 0.01), seq(0.10, 0.25, 0.01))
marginal <- list(0.3)
lam <- 0.5
size <- 2
prob <- 0.75
Rey <- matrix(0.4, 4, 4)
diag(Rey) <- 1
Sim1 <- rcorrvar(n = n, k_cat = 1, k_cont = 1, k_pois = 1, k_nb = 1,
method = "Polynomial", means = Stcum[1, 1],
vars = Stcum[1, 2]^2, skews = Stcum[1, 3],
skurts = Stcum[1, 4], fifths = Stcum[1, 5],
sixths = Stcum[1, 6], Six = Six[[1]], marginal = marginal,
lam = lam, size = size, prob = prob, rho = Rey,
seed = seed)
rcorrvar
names(Sim1)
Sim1$maxerr
Sim1$summary_targetcont
Sim1$summary_continuous
Sim1$sixth_correction
Sim1$valid.pdf
Sim1 <- rcorrvar(n = n, k_cat = 1, k_cont = 2, k_pois = 1, k_nb = 1,
method = "Polynomial", means = Stcum[, 1],
vars = Stcum[, 2]^2, skews = Stcum[, 3],
skurts = Stcum[, 4], fifths = Stcum[, 5],
sixths = Stcum[, 6], Six = Six, marginal = marginal,
lam = lam, size = size, prob = prob, rho = Rey,
seed = seed)
Rey <- matrix(0.4, 5, 5)
diag(Rey) <- 1
Sim1 <- rcorrvar(n = n, k_cat = 1, k_cont = 2, k_pois = 1, k_nb = 1,
method = "Polynomial", means = Stcum[, 1],
vars = Stcum[, 2]^2, skews = Stcum[, 3],
skurts = Stcum[, 4], fifths = Stcum[, 5],
sixths = Stcum[, 6], Six = Six, marginal = marginal,
lam = lam, size = size, prob = prob, rho = Rey,
seed = seed)
Sim1$valid.pdf
Sim1$sixth_correction
Six[[1]]
Rey <- matrix(0.4, 4, 4)
diag(Rey) <- 1
Rey <- matrix(0.4, 4, 4)
diag(Rey) <- 1
# Make sure Rey is within upper and lower correlation limits
valid <- valid_corr(k_cat = 1, k_cont = 1, k_pois = 1, k_nb = 1,
method = "Polynomial", means = Stcum[1, 1],
vars = Stcum[1, 2]^2, skews = Stcum[1, 3],
skurts = Stcum[1, 4], fifths = Stcum[1, 5],
sixths = Stcum[1, 6], Six = list(Six[[1]]), marginal = marginal,
lam = lam, size = size, prob = prob, rho = Rey,
seed = seed)
# Simulate variables without error loop
Sim1 <- rcorrvar(n = n, k_cat = 1, k_cont = 1, k_pois = 1, k_nb = 1,
method = "Polynomial", means = Stcum[1, 1],
vars = Stcum[1, 2]^2, skews = Stcum[1, 3],
skurts = Stcum[1, 4], fifths = Stcum[1, 5],
sixths = Stcum[1, 6], Six = list(Six[[1]]), marginal = marginal,
lam = lam, size = size, prob = prob, rho = Rey,
seed = seed)
Sim1$valid.pdf
Sim1$sixth_correction
options(scipen = 999)
seed <- 1234
n <- 10000
Dist <- c("Logistic", "Weibull")
Params <- list(c(0, 1), c(3, 5))
Stcum1 <- calc_theory(Dist[1], Params[[1]])
Stcum2 <- calc_theory(Dist[2], Params[[2]])
Stcum <- rbind(Stcum1, Stcum2)
rownames(Stcum) <- Dist
colnames(Stcum) <- c("mean", "sd", "skew", "skurtosis", "fifth", "sixth")
Stcum
Six <- list(seq(1.7, 1.8, 0.01), seq(0.10, 0.25, 0.01))
marginal <- list(0.3)
lam <- 0.5
size <- 2
prob <- 0.75
Rey <- matrix(0.4, 5, 5)
diag(Rey) <- 1
Sim1 <- rcorrvar(n = n, k_cat = 1, k_cont = 2, k_pois = 1, k_nb = 1,
method = "Fleishman", means = Stcum[, 1],
vars = Stcum[, 2]^2, skews = Stcum[, 3],
skurts = Stcum[, 4], marginal = marginal,
lam = lam, size = size, prob = prob, rho = Rey,
seed = seed)
valid <- valid_corr(k_cat = 1, k_cont = 2, k_pois = 1, k_nb = 1,
method = "Polynomial", means = Stcum[, 1],
vars = Stcum[, 2]^2, skews = Stcum[, 3],
skurts = Stcum[, 4], marginal = marginal,
lam = lam, size = size, prob = prob, rho = Rey,
seed = seed)
valid <- valid_corr(k_cat = 1, k_cont = 2, k_pois = 1, k_nb = 1,
method = "Fleishman", means = Stcum[, 1],
vars = Stcum[, 2]^2, skews = Stcum[, 3],
skurts = Stcum[, 4], marginal = marginal,
lam = lam, size = size, prob = prob, rho = Rey,
seed = seed)
library(SimMultiCorrData)
Sim1 <- rcorrvar(n = n, k_cat = 1, k_cont = 2, k_pois = 1, k_nb = 1,
method = "Fleishman", means = Stcum[, 1],
vars = Stcum[, 2]^2, skews = Stcum[, 3],
skurts = Stcum[, 4], marginal = marginal,
lam = lam, size = size, prob = prob, rho = Rey,
seed = seed)
library(SimMultiCorrData)
names(Sim1)
Sim1$summary_continuous
system("R CMD Rd2pdf C:\\Users\\Allison\\Documents\\SimMultiCorrData")
library(SimMultiCorrData)
library(SimMultiCorrData)
B <- calc_theory("Beta", c(4, 1.5))
S <- calc_lower_skurt("Polynomial", B[3], B[5], B[6], Six = seq(0.01, 10, 0.01))
S$SixCorr1
B <- calc_theory("Beta", c(4, 1.5))
S <- calc_lower_skurt("Polynomial", B[3], B[5], B[6])
B <- calc_theory("Beta", c(0.5, 0.5))
S <- calc_lower_skurt("Polynomial", B[3], B[5], B[6], Six = seq(0.01, 10, 0.01))
S$SixCorr1
B <- calc_theory("Logistic", c(0, 1))
S <- calc_lower_skurt("Polynomial", B[3], B[5], B[6], Six = seq(0.01, 10, 0.01))
B <- calc_theory("Laplace", c(0, 1))
S <- calc_lower_skurt("Polynomial", B[3], B[5], B[6])
?calc_lower_skurt
method = "Polynomial"; skews = B[3],
fifths = B[5]; sixths = B[6]; Skurt = NULL; Six = seq(0.01, 10, 0.01)
xstart = NULL; seed = 104; n = 50
method = "Polynomial"; skews = B[3]
fifths = B[5]; sixths = B[6]; Skurt = NULL; Six = seq(0.01, 10, 0.01)
xstart = NULL; seed = 104; n = 50
error1 <- "Lower boundary could not be found.
Try more starting values (increase n)
or a different seed or Six vector.
Also verify standardized cumulant values.\n"
error2 <- "Only invalid pdf constants could be found.
Try more starting values (increase n)
or a different seed or Skurt vector.
Also verify standardized cumulant values.\n"
SixCorr1 <- NULL
SkurtCorr1 <- NULL
poly_skurt <- function(c) {
c <- as.numeric(c)
pskurtosis <- 24 * (2 * c[2]^4 + 96 * c[2]^3 * c[4] + c[1]^3 *
(c[3] + 10 * c[5]) + 30 * c[2]^2 *
(6 * c[3]^2 + 64 * c[4]^2 +
140 * c[3] * c[5] + 945 * c[5]^2) +
c[1]^2 * (2 * c[2]^2 + 18 * c[3]^2 +
36 * c[2] * c[4] +
192 * c[4]^2 +
375 * c[3] * c[5] +
2250 * c[5]^2) +
36 * c[2] * c[4] *
(125 * c[3]^2 + 528 * c[4]^2 +
3360 * c[3] * c[5] +
25725 * c[5]^2) +
3 * c[1] *
(45 * c[3]^3 + 1584 * c[3] * c[4]^2 +
1590 * c[3]^2 * c[5] +
21360 * c[4]^2 * c[5] +
21525 * c[3] * c[5]^2 +
110250 * c[5]^3 +
12 * c[2]^2 * (c[3] + 10 * c[5]) +
8 * c[2] * c[4] *
(32 * c[3] + 375 * c[5])) +
9 * (45 * c[3]^4 + 8704 * c[4]^4 +
2415 * c[3]^3 * c[5] +
932400 * c[4]^2 * c[5]^2 +
3018750 * c[5]^4 +
20 * c[3]^2 *
(178 * c[4]^2 +
2765 * c[5]^2) +
35 * c[3] *
(3104 * c[4]^2 * c[5] +
18075 * c[5]^3)))
return(pskurtosis)
}
if (length(xstart) == 0) {
set.seed(seed)
cstart1 <- runif(n, min = 0, max = 2)
cstart2 <- runif(n, min = -1, max = 1)
cstart3 <- runif(n, min = -1, max = 1)
cstart4 <- runif(n, min = -0.025, max = 0.025)
cstart5 <- runif(n, min = -0.025, max = 0.025)
lstart1 <- runif(n, min = -5, max = 5)
lstart2 <- runif(n, min = -0.025, max = 0.025)
lstart3 <- runif(n, min = -0.025, max = 0.025)
lstart4 <- runif(n, min = -0.025, max = 0.025)
xstart <- cbind(cstart1, cstart2, cstart3, cstart4,
cstart5, lstart1, lstart2, lstart3,
lstart4)
}
test <- numeric(nrow(xstart))
for (i in 1:nrow(xstart)) {
test[i] <-
ifelse(!is.na(poly_skurt_check(xstart[i, ],
a = c(skews, fifths,
sixths))[1]),
TRUE, FALSE)
}
xstart2 <- xstart[which(test == TRUE), , drop = FALSE]
constants0 <- NULL
converged <- NULL
for (i in 1:nrow(xstart2)) {
nl_solution <- nleqslv(x = xstart2[i, ],
fn = poly_skurt_check,
a = c(skews, fifths, sixths),
method = "Broyden",
control = list(ftol = 1e-05))
if (nl_solution$termcd == 1) {
converged <- rbind(converged, nl_solution$x)
}
}
library(nleqslv)
converged <- NULL
for (i in 1:nrow(xstart2)) {
nl_solution <- nleqslv(x = xstart2[i, ],
fn = poly_skurt_check,
a = c(skews, fifths, sixths),
method = "Broyden",
control = list(ftol = 1e-05))
if (nl_solution$termcd == 1) {
converged <- rbind(converged, nl_solution$x)
}
}
converged
constants <- converged[!duplicated(converged), , drop = FALSE]
constants
constants <- data.frame()
nrow(constants) == 0
v <- 1
while (nrow(constants) == 0) {
xstart2 <- NULL
converged <- NULL
while (is.null(xstart2)) {
test <- numeric(nrow(xstart))
for (i in 1:nrow(xstart)) {
test[i] <-
ifelse(!is.na(poly_skurt_check(xstart[i, ],
a = c(skews,
fifths,
sixths +
Six[v]))[1]),
TRUE, FALSE)
}
xstart2 <- xstart[which(test == TRUE), , drop = FALSE]
v <- v + 1
if (v > length(Six)) break
}
if (is.null(xstart2)) {
stop(error1)
} else {
for (i in 1:nrow(xstart2)) {
nl_solution <- nleqslv(x = xstart2[i, ],
fn = poly_skurt_check,
a = c(skews, fifths,
sixths + Six[v - 1]),
method = "Broyden",
control = list(ftol = 1e-05))
if (nl_solution$termcd == 1) {
converged <- rbind(converged, nl_solution$x)
}
}
}
constants <- converged[!duplicated(converged), , drop = FALSE]
if(v > length(Six)) break
}
SixCorr1 <- Six[v - 1]
}
constants <- data.frame()
v <- 1
while (nrow(constants) == 0) {
xstart2 <- NULL
converged <- NULL
while (is.null(xstart2)) {
test <- numeric(nrow(xstart))
for (i in 1:nrow(xstart)) {
test[i] <-
ifelse(!is.na(poly_skurt_check(xstart[i, ],
a = c(skews,
fifths,
sixths +
Six[v]))[1]),
TRUE, FALSE)
}
xstart2 <- xstart[which(test == TRUE), , drop = FALSE]
v <- v + 1
if (v > length(Six)) break
}
if (is.null(xstart2)) {
stop(error1)
} else {
for (i in 1:nrow(xstart2)) {
nl_solution <- nleqslv(x = xstart2[i, ],
fn = poly_skurt_check,
a = c(skews, fifths,
sixths + Six[v - 1]),
method = "Broyden",
control = list(ftol = 1e-05))
if (nl_solution$termcd == 1) {
converged <- rbind(converged, nl_solution$x)
}
}
}
constants <- converged[!duplicated(converged), , drop = FALSE]
if(v > length(Six)) break
}
constants
SixCorr1 <- Six[v - 1]
SixCorr1
devtools::use_testthat()
?calc_theory
calc_theory(Dist = "Chisq", params = 2)
calc_theory(Dist = "Chisq", params = 2)[6]
calc_theory(Dist = "Pareto", params = c(1, 10))
calc_theory(Dist = "Laplace", params = c(0, 1))
calc_theory(Dist = "Laplace", params = c(0, 1))[6] == 30
library(devtools)
?expect_equal
all.equal(calc_theory(Dist = "Laplace", params = c(0, 1))[6], 30)
expect_equivalent(calc_theory(Dist = "Laplace", params = c(0, 1))[6], 30)
all.equal(calc_theory(Dist = "Laplace", params = c(0, 1))[6], 30, check.attributes = FALSE)
library(VGAM)
?VGAM
?calc_theory
calc_theory(Dist = "Beta-Normal", params = c(0.1, 4, 2, 1))
all.equal(calc_theory(Dist = "Beta-Normal", params = c(0.1, 4, 2, 1))[6], -1.2950460, check.attributes = FALSE)
?expect_equivalent
all.equal(calc_theory(Dist = "Beta-Normal", params = c(0.1, 4, 2, 1))[6], -1.2950460, tolerance = 1e-5, check.attributes = FALSE)
calc_theory(Dist = "Dagum", params = c(1, 1, 2)
)
calc_theory(fx = function(x) 0.5 * dbeta(x, 6, 3) +
0.2 * dbeta(x, 4, 1.5) + 0.3 * dbeta(x, 10, 20),
lower = 0, upper = 1)
calc_theory(fx = function(x) 0.4 * dnorm(x, -2, 1) +
0.6 * dnorm(x, 2, 1),
lower = -Inf, upper = Inf, subs = 500)
calc_theory(fx = function(x) 0.4 * dnorm(x, -2, 1) +
0.6 * dnorm(x, 2, 1),
lower = -Inf, upper = Inf, sub = 500)
?calc_lower_skurt
library(SimMultiCorrData)
library(SimCorrMix)
pis <- c(0.7, 0.3)
mus <- c(Stcum1[1], Stcum2[1])
sigmas <- c(Stcum1[2], Stcum2[2])
skews <- c(Stcum1[3], Stcum2[3])
skurts <- c(Stcum1[4], Stcum2[4])
fifths <- c(Stcum1[5], Stcum2[5])
sixths <- c(Stcum1[6], Stcum2[6])
#Six <- list(seq(0.01, 10, 0.01), seq(0.01, 10, 0.01))
Estcum <- calc_mixmoments(pis, mus, sigmas, skews, skurts, fifths, sixths)
S <- calc_lower_skurt("Polynomial", skews = Estcum[3], fifths = Estcum[5], sixths = Estcum[6], Six = seq(0.01, 10, 0.01))
S$SixCorr1
method = "Polynomial"; skews = Estcum[3]
fifths = Estcum[5]; sixths = Estcum[6]; Skurt = NULL; Six = seq(0.01, 10, 0.01)
xstart = NULL; seed = 104; n = 50
W <- calc_theory("Weibull", c(3, 5))
calc_lower_skurt(method = "Fleishman", skews = W[3])
calc_lower_skurt(method = "Fleishman",
skews = W[3], Skurt = seq(1.1, 2, 0.01))
calc_lower_skurt(method = "Fleishman",
skews = W[3], Skurt = seq(1.14, 2, 0.001))
calc_lower_skurt(method = "Polynomial", skews = W[3],
fifths = W[5], sixths = W[6])
calc_lower_skurt(method = "Polynomial", skews = W[3],
fifths = W[5], sixths = W[6] + 0.15, Skurt = seq(0.07, 2, 0.001))
calc_lower_skurt(method = "Fleishman",
skews = 0)
calc_lower_skurt(method = "Fleishman",
skews = 0, Skurt = seq(1.1, 2, 0.001))
calc_lower_skurt(method = "Fleishman",
skews = 0, Skurt = seq(1.1, 2, 0.01))
S <- calc_lower_skurt(method = "Fleishman",
skews = 0, Skurt = seq(1.1, 2, 0.01))
rho_pZ <- S$Min[,"c1"] + 3 * S$Min[,"c3"]
rho_pZ
rho_pZ == 1
print(rho_pZ, digits = 20)
Dist <- c("Rayleigh", "Pareto", "Beta", "Chisq")
Params <- list(c(2, 4), c(10, 20), c(4, 1.5), 3)
# list of sixth cumulant corrections to correct for invalid power method pdfs
Six <- list(seq(0.12, 5, 0.01), seq(0.01, 6, 0.01), 0.03, NULL)
# Calculate standardized cumulants
Stcum1 <- calc_theory(Dist[1], Params[[1]])
Stcum2 <- calc_theory(Dist[2], Params[[2]])
Stcum3 <- calc_theory(Dist[3], Params[[3]])
Stcum4 <- calc_theory(Dist[4], Params[[4]])
Stcum <- cbind(Stcum1, Stcum2, Stcum3, Stcum4)
colnames(Stcum) <- Dist
rownames(Stcum) <- c("mean", "sd", "skew", "skurtosis", "fifth", "sixth")
library("PoisBinOrdNonNor")
library("BinOrdNonNor")
set.seed(seed)
ConstantsPBON <- Fleishman.coef.NN(Stcum[3, ], Stcum[4, ])
Valid.pdfPBON <- numeric(ncont)
for (i in 1:ncont) {
Valid.pdfPBON[i] <- pdf_check(c = as.numeric(ConstantsPBON[, i]),
method = "Fleishman")$valid.pdf
}
Dist[Valid.pdfPBON == FALSE]
